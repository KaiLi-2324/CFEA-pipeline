import glob
import gzip
import argparse
import multiprocessing


"""
@Author: likai
@Email: likai@wibe.ac.cn
this script is designed to merge CpG positions in the positive and
negative strand
"""


def get_cov_files(cov_dir):
    """
    get all coverage file generated by bismark
    :param cov_dir: directory to coverage file by bismark
    :return: none
    """
    print(f"Start reading from {cov_dir}")
    cov_files = glob.glob(f"{cov_dir}/*/*.cov.gz")
    return cov_files


def parse_ref(path_ref):
    """
     read in the reference CpG file into a python dict
    :param path_ref: path to reference CpG position in the whole genome fasta file
    :return: python dict, key stands for chromosome + position
    """
    print("Start reading from {}".format(path_ref))
    ref_dict = dict()
    with gzip.open(path_ref) as f:
        for line in f:
            line = line.decode()
            line_list = line.strip().split()
            key = line_list[0] + "-" + line_list[-1]
            ref_dict[key] = 1
    return ref_dict


def parse_cov(path_cov, ref_dict):
    """
    merge CpG position in the positive and negative strand
    :param path_cov:
    :param ref_dict:
    :return:
    """
    try:
        print("Start reading from {}".format(path_cov))
        path_out = path_cov[:-6] + "met.cov"
        path_temp = path_cov[:-6] + "tmp.cov"
        out = open(path_out, "w+")
        temp = open(path_temp, "w+")
        out_lines = dict()
        with gzip.open(path_cov) as f:
            for line in f:
                line = line.decode()
                line_list = line.strip().split()
                key_positive = line_list[0] + "-" + line_list[1]
                key_negative = line_list[0] + "-" + str(int(line_list[1]) - 1)
                if key_positive in ref_dict:
                    out_lines[key_positive] = line_list[:3] + line_list[4:]
                elif key_negative in ref_dict:
                    if key_negative in out_lines:
                        negative_value = out_lines[key_negative]
                        negative_read = list(map(int, negative_value[3:]))
                        line_list_read = list(map(int, line_list[4:]))
                        out_read = [negative_read[0] + line_list_read[0], negative_read[1] + line_list_read[1]]
                        out_read = list(map(str, out_read))
                        out_lines[key_negative] = negative_value[:3] + out_read
                    else:
                        out_lines[key_negative] = [line_list[0], str(int(line_list[1]) - 1),
                                                   str(int(line_list[2]) - 1)] + line_list[4:]
                else:
                    temp.write(line)
        print("Start writing to {}".format(path_out))
        for each_key in out_lines:
            value = out_lines[each_key]
            out.write("\t".join(value) + "\n")
    except Exception as e:
        print(e)


def multiprocess_run(cov_files, ref_dict, num_process):
    pool = multiprocessing.Pool(processes=int(num_process))
    for each_cov in cov_files:
        pool.apply_async(parse_cov, (each_cov, ref_dict,))
    pool.close()
    pool.join()


def main():
    parser = argparse.ArgumentParser(description="A program to extract CPG from bismark coverage files")
    parser.add_argument("-i", action="store", dest="cov_dir")
    parser.add_argument("-p", action="store", dest="num_process", help="processes to use in the program", default=10)
    parser.add_argument("-f", action="store", dest="path_ref", help="path to hg19 whole genome CPGs")
    results = parser.parse_args()
    if not all([results.cov_dir, results.num_process, results.path_ref]):
        print("too few arguments, type -h for more information")
        exit(-1)
    cov_dir = results.cov_dir if not results.cov_dir.endswith("/") else results.cov_dir.rstrip("/")
    num_process = results.num_process
    path_ref = results.path_ref
    cov_files = get_cov_files(cov_dir)
    ref_dict = parse_ref(path_ref)
    multiprocess_run(cov_files, ref_dict, num_process)


if __name__ == '__main__':
    main()
